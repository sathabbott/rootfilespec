from __future__ import annotations

from rootfilespec.bootstrap import TList
from rootfilespec.bootstrap.TStreamerInfo import (
    ClassDef,
    TStreamerInfo,
)
from rootfilespec.dispatch import DICTIONARY, normalize

PREAMBLE = """# Generated by streamerinfo_to_classes
from __future__ import annotations

from typing import Annotated, Self

import numpy as np

from rootfilespec.bootstrap import (
    StreamedObject,
    TList,
    TNamed,
    TObjArray,
    TObject,
    TString,
)
from rootfilespec.bootstrap.assumed import (
    ROOT3a3aTIOFeatures,
    TArrayD,
    TArrayI,
    TVirtualIndex,
)
from rootfilespec.bootstrap.TKey import DICTIONARY
from rootfilespec.structutil import (
    BasicArray,
    Fmt,
    Pointer,
    StdVector,
    serializable,
)
"""


def streamerinfo_to_classes(streamerinfo: TList) -> str:
    lines: list[str] = list(PREAMBLE.split("\n"))

    classes: dict[str, ClassDef] = {}

    for item in streamerinfo.items:
        if not isinstance(item, TStreamerInfo):
            continue
        clsname = normalize(item.fName.fString)
        if clsname in DICTIONARY:
            lines.append(f"# Class {clsname} already in dictionary, skipping\n")
            continue
        if "edm3a3a" in clsname:
            lines.append(f"# Class {clsname} is an EDM class, skipping\n")
            continue
        classdef = item.class_definition()
        classes[classdef.name] = classdef

    # Write out in dependency order
    def write(classdef: ClassDef):
        for dep in classdef.dependencies:
            depdef = classes.pop(dep, None)
            if depdef is not None:
                write(depdef)
        lines.append(classdef.code)

    while classes:
        _, classdef = classes.popitem()
        write(classdef)

    return "\n".join(lines)
